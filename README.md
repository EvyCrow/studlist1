# Несколько пояснений к коду, чтобы было проще читать эти несчастные 200 строк

## 6-13:
Задается структура, в которой хранится информация о студентах. Она включает в себя:
ФИО
Дату рождения
Оценки (8 штук)
Номер курса
И номер группы

## 14-18:
Перегрузка для нормального выведения структуры. Не уверена до конца в ее необходимости, но убирать не рискнула

## Цикл на 25 и до конца:
Неизменная классика, "меню", позволяющее несколько раз запускать программу

## 36:
leng - переменная для подсчета строк в файле. Понадобится потом для задания массива структур
Это и происходит на строках 39-43, после чего файл открывается и открывается снова для последующей работы

**Переменная а, объявленная на _44_ строке сыграет роль в заполнении _массива структур_*

*Строка buff*, объявленная на 49 строке нужна для подстраховки. С ней пойдет следующая работа
## 50-80:
Цикл на 50-80 предназначен для заполнения массива структур данными из файла. Строки в файле записаны определенным образом
Нарушение структуры файла будет эквивалентно нарушению работы программы. Условие заданно так, чтобы цикл перебирал строки,
пока файл не закончится

`list [a]`
Тут и пригождается объявленная выше переменная. Она будет накапливаться в конце цикла, позволяя "шагать" по массиву структур

На 52 переменной *buff* присваевается значение считываемой s
## 53:
В структуру записывается информация о курсе - из типа char число переделывается в int и записывается, после чего из *буферной
строки* стирается два символа, соответсвующие номеру курса и пробелу после него **KURSE**

***ВСЕ ПРОБЕЛЫ В ФАЙЛЕ НУЖНЫ ДЛЯ УДОБСТВА ЧТЕНИЯ ПОЛЬЗОВАТЕЛЯ И ВНЕСЕНИЯ КОРРЕКТИРОВОК***

## 56-57:
К промежуточной строке прибавляются первые два символа буферной строки, соотвествующие номеру группы. После они преобразовываются
в int и записываются в часть структуры, предназначенную для групп **EINHEIT**
На 59 очистка строки, чтобы не забивать память, после обрезание *буферной строки*

## 62-64:
В часть структуры, соответсвующей дате, записывается... дата.**DATUM**
Она задана строкой для корректного отображения. Операций в основном коде с ней нет

## 66-74:
Цикл предназначен для заполнения массива оценок **NOTEN** данными. Элементу массива присваевается значение только тогда, когда элемент
строки не являет собой пробел. Переменная kk нужна для смены элемента массива (так как в цикле это не задать, использованно отдельно)

## 76-79
Подчищаются лишние символы, остаток строки записывается в имя **NAMEN**
После *буферная строка* очищается, а переменная а накапливает значение

## Объявление переменных на 84-88:
***Если что, речь идет о среднем оценок для студентов на каждом курсе***
Как не трудно догадаться, _max_ для максимумов, _min_ для минимумов. С ними в последствии будут сравниваться входные значения
**Номер в названии переменной значит номер курса**
_ma_ и _mi_ в свою очередь представляют условный порядковый номер строки, соответствующий минимальному и максимальному значению на курсе
_aver_ - переменная для промежуточных рассчетов

## Цикл на 90-177
Тут пригождается _leng_. Проверяется весь массив структур

### 92-96:
Вложенный цикл для суммирования оценок, потом итог делится на 8 для получения среднего

### Switch на 98-175:
Проверяется курс конкретного рассматриваемого студента. В зависимости от него, программа идет по одному из путей - _case(1-5)_
Каждый case сделан аналогично остальным, потому рассмотрю только один

### case(1)
Внутри лежат два условия, сравнивающие полученное среднее значение с минимумом и максимумом (по умолчанию 8888 и 0 соответственно)
В каждом условии есть присвоение нового значения переменным min/max (для последующего сравнения) и переменным mi/ma для корректного вывода в последствии
_Как было упомянуто выше, в mi/ma хранится номер студента, подходящего под условие - минимальный средний балл для mi, максимальный для ma_

После всего среднее значение зануляется

## Ну и 174-186 - вывод:
Выводится худшие средние баллы в зависимости от курса и имя студента, имеющего такие баллы. Аналогично для лучших баллов чуть позже. Думаю, в пояслении
не нуждается


***Файл, приложенный к программе, сгенерирован случайным образом. Все совпадения случайны***

